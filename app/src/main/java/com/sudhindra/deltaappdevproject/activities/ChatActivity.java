package com.sudhindra.deltaappdevproject.activities;

import android.Manifest;
import android.app.ProgressDialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.provider.MediaStore;
import android.util.Log;
import android.view.MenuItem;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.ImageView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityOptionsCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.recyclerview.widget.SimpleItemAnimator;

import com.google.android.material.chip.Chip;
import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.WriteBatch;
import com.google.mlkit.nl.smartreply.SmartReply;
import com.google.mlkit.nl.smartreply.SmartReplyGenerator;
import com.google.mlkit.nl.smartreply.SmartReplySuggestion;
import com.google.mlkit.nl.smartreply.SmartReplySuggestionResult;
import com.google.mlkit.nl.smartreply.TextMessage;
import com.sudhindra.deltaappdevproject.GlideApp;
import com.sudhindra.deltaappdevproject.R;
import com.sudhindra.deltaappdevproject.adapters.MessageAdapter;
import com.sudhindra.deltaappdevproject.clients.CloudStorageClient;
import com.sudhindra.deltaappdevproject.clients.FilesClient;
import com.sudhindra.deltaappdevproject.clients.FirestoreClient;
import com.sudhindra.deltaappdevproject.clients.ShareClient;
import com.sudhindra.deltaappdevproject.databinding.ActivityChatBinding;
import com.sudhindra.deltaappdevproject.models.ChatChannel;
import com.sudhindra.deltaappdevproject.models.Message;
import com.thekhaeng.pushdownanim.PushDownAnim;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

import javax.inject.Inject;

import dagger.hilt.android.AndroidEntryPoint;

import static com.thekhaeng.pushdownanim.PushDownAnim.MODE_STATIC_DP;

@AndroidEntryPoint
public class ChatActivity extends AppCompatActivity {

    public static final String TAG = "ChatActivity", MESSAGES = "messages", CHANNEL_ID = "channelId", ENGAGED_CHAT_CHANNELS = "engagedChatChannels", CHANNEL_MODE = "channelMode";
    public static final int IMAGE_REQUEST = 23, FILE_REQUEST = 78, CHANNEL_EXISTS = 34, CHECK_FOR_CHANNEL = 45;
    private int mode;
    private ActivityChatBinding binding;
    private String otherUserId, otherUserName;
    private String currentUserName;

    @Inject
    ShareClient shareClient;

    private boolean receivingData;
    private Intent intent;

    // Input
    private String messageText;
    private Uri imageUri = null;
    private Uri fileUri = null;
    private Message newMessage;

    private boolean firstTime = true;

    // Files
    private File chatChannelFilesDir;
    private boolean receivingFileFromOtherApp;

    // Firebase
    private boolean newChatChannel = false, firstTimeChat;
    private String chatChannelId;
    private FirebaseAuth mAuth = FirebaseAuth.getInstance();
    private CollectionReference chatChannelsCollection = FirestoreClient.getInstance().getChatChannelCollection();
    private DocumentReference userInfoDocRef = FirestoreClient.getInstance().getUserInfoDocRef(mAuth.getUid());
    private static final int MESSAGES_LIMIT = 20;
    private DocumentSnapshot lastMessage = null;
    private boolean loading = true, endOfCollection = false;

    // UI
    private ArrayList<Message> messages;
    private MessageAdapter messageAdapter = new MessageAdapter(mAuth.getUid());
    private LinearLayoutManager linearLayoutManager;

    private ProgressDialog progressDialog;
    private long messageTime;
    private File newMessageFile;

    // Smart Reply
    private ArrayList<TextMessage> textMessages = new ArrayList<>();
    private SmartReplyGenerator smartReplyGenerator = SmartReply.getClient();
    private ArrayList<String> replies = new ArrayList<>();
    /**
     * Max number of Smart Replies generated by ML Kit is 3
     */
    private Chip[] smartReplyChips = new Chip[3];

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        Log.i(TAG, "onNewIntent: ");
        String notificationUserName = intent.getStringExtra("otherUserName");
        if (!notificationUserName.equals(otherUserName)) {
            Log.i(TAG, "onNewIntent: recreate");
            setIntent(intent);
            recreate();
        } else
            Log.i(TAG, "onNewIntent: noRecreate");
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityChatBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());
        setSupportActionBar(binding.chatToolbar);
        getSupportActionBar().setTitle(null);
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        getSupportActionBar().setDisplayShowHomeEnabled(true);
        getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR);

        progressDialog = new ProgressDialog(this, R.style.AppTheme_ProgressDialogTheme);
        progressDialog.setMessage("Loading File...");
        progressDialog.setCancelable(false);
        progressDialog.setCanceledOnTouchOutside(false);

        PushDownAnim.setPushDownAnimTo(binding.chatOtherUserProfile).setScale(MODE_STATIC_DP, PushDownAnim.DEFAULT_PUSH_STATIC);
        PushDownAnim.setPushDownAnimTo(binding.chatOtherUsername).setScale(MODE_STATIC_DP, PushDownAnim.DEFAULT_PUSH_STATIC);
        PushDownAnim.setPushDownAnimTo(binding.chatChooseAttachmentBt).setScale(MODE_STATIC_DP, PushDownAnim.DEFAULT_PUSH_STATIC);
        PushDownAnim.setPushDownAnimTo(binding.chatSendMessageBt).setScale(MODE_STATIC_DP, PushDownAnim.DEFAULT_PUSH_STATIC);
        PushDownAnim.setPushDownAnimTo(binding.chatImgCancelBt).setScale(MODE_STATIC_DP, PushDownAnim.DEFAULT_PUSH_STATIC);
        PushDownAnim.setPushDownAnimTo(binding.chatFileCancelBt).setScale(MODE_STATIC_DP, PushDownAnim.DEFAULT_PUSH_STATIC);

        messages = new ArrayList<>();

        intent = getIntent();

        otherUserId = intent.getStringExtra("otherUserId");
        otherUserName = intent.getStringExtra("otherUserName");
        currentUserName = intent.getStringExtra("currentUserName");

        mode = intent.getIntExtra(CHANNEL_MODE, CHECK_FOR_CHANNEL);

        GlideApp.with(this)
                .load(CloudStorageClient.getInstance().getProfileImgRef(otherUserId))
                .placeholder(R.drawable.default_profile)
                .error(R.drawable.default_profile)
                .into(binding.chatOtherUserProfile);
        binding.chatOtherUsername.setText(otherUserName);

        binding.chatOtherUserProfile.setOnClickListener(v -> showUserProfile());

        binding.chatOtherUsername.setOnClickListener(v -> showUserProfile());

        binding.chatChooseAttachmentBt.setOnClickListener(v -> showAttachmentOptions());

        binding.chatSendMessageBt.setOnClickListener(v -> {
            messageText = binding.chatMessageEt.getText().toString();
            if (messageText.trim().isEmpty() && imageUri == null && fileUri == null) {
                Toast.makeText(this, "Enter a Message", Toast.LENGTH_SHORT).show();
                return;
            }
            if (!messageText.trim().isEmpty() || imageUri != null || fileUri != null) {
                binding.chatMessageEt.setText(null);
                binding.chatImgCard.setVisibility(View.GONE);
                binding.chatFileCard.setVisibility(View.GONE);
                newMessage = new Message(messageText, mAuth.getUid(), otherUserId, currentUserName, Message.TEXT, System.currentTimeMillis());
                sending();
                if (!newChatChannel)
                    checkForImageOrFile(newMessage.getSentTimeInMillis());
                else
                    createNewChatChannel(newMessage.getSentTimeInMillis());
            }
        });

        binding.chatImgCancelBt.setOnClickListener(v -> {
            imageUri = null;
            binding.chatImgCard.setVisibility(View.GONE);
        });

        binding.chatFileCancelBt.setOnClickListener(v -> {
            fileUri = null;
            binding.chatFileCard.setVisibility(View.GONE);
        });

        buildRecyclerView();

        if (mode == CHANNEL_EXISTS) {
            chatChannelId = intent.getStringExtra(CHANNEL_ID);
            firstTimeChat = false;
            firstTime = true;
            chatChannelFilesDir = FilesClient.getMessageFilesDirForChatChannel(this, chatChannelId);
            messageAdapter.setChannelFilesDir(chatChannelFilesDir);
            loadMessages();
        } else
            getChatChannel();

        smartReplyChips[0] = binding.chip1;
        smartReplyChips[1] = binding.chip2;
        smartReplyChips[2] = binding.chip3;

        for (Chip chip : smartReplyChips)
            chip.setOnClickListener(this::sendSmartReply);

        receivingData = intent.getBooleanExtra("receivingData", false);
        if (receivingData) {
            String type = intent.getType();
            if (mAuth.getCurrentUser() != null) {
                if ("text/plain".equals(type))
                    handleTextSharing();
                else if (type.startsWith("image/"))
                    handleImageSharing();
                else if (type.startsWith("audio/") || "application/pdf".equals(type))
                    handleFileSharing();
            }
        }
    }

    private void showUserProfile() {
        Intent intent = new Intent(this, UserActivity.class);
        intent.putExtra("uid", otherUserId);
        intent.putExtra("currentUserName", currentUserName);
        startActivity(intent);
    }

    private void buildRecyclerView() {
        binding.chatRecyclerView.setHasFixedSize(true);
        // To remove the Default Dim animation when onItemChanged() is called
        ((SimpleItemAnimator) Objects.requireNonNull(binding.chatRecyclerView.getItemAnimator())).setSupportsChangeAnimations(false);
        messageAdapter.setMessages(messages);
        messageAdapter.setListener(new MessageAdapter.MessageListener() {
            @Override
            public void onImageClicked(int pos, ImageView imageView) {
                showImage(pos, imageView);
            }

            @Override
            public void onFileClicked(int pos) {
                handleFileClick(pos, messages.get(pos));
            }

            @Override
            public void onFileLongClicked(int pos) {
                handleFileLongClick(pos, messages.get(pos));
            }
        });
        linearLayoutManager = new LinearLayoutManager(this);
        linearLayoutManager.setReverseLayout(true);
        binding.chatRecyclerView.setAdapter(messageAdapter);
        binding.chatRecyclerView.setLayoutManager(linearLayoutManager);

        binding.chatDownArrow.setOnClickListener(v -> {
            hideDownArrow();
            binding.chatRecyclerView.smoothScrollToPosition(0);
        });

        binding.chatRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
                if (dy < 0) {
                    if (linearLayoutManager.findFirstVisibleItemPosition() > 0) showDownArrow();
                    int visibleItemCount = linearLayoutManager.getChildCount();
                    int totalItemCount = linearLayoutManager.getItemCount();
                    int pastVisibleItems = linearLayoutManager.findFirstVisibleItemPosition();

                    if (loading)
                        if ((visibleItemCount + pastVisibleItems) >= totalItemCount) {
                            loading = false;
                            Log.i(TAG, "onScrolled: lastItem");
                            paginate();
                        }
                } else if (linearLayoutManager.findFirstVisibleItemPosition() == 0) hideDownArrow();
            }
        });
    }

    private void showDownArrow() {
        if (binding.chatDownArrow.getVisibility() == View.GONE) {
            Animation showAnim = AnimationUtils.loadAnimation(this, R.anim.down_arrow_show_anim);
            binding.chatDownArrow.setAnimation(showAnim);
            binding.chatDownArrow.setVisibility(View.VISIBLE);
        }
    }

    private void hideDownArrow() {
        if (binding.chatDownArrow.getVisibility() == View.VISIBLE) {
            Animation hideAnim = AnimationUtils.loadAnimation(this, R.anim.down_arrow_hide_anim);
            binding.chatDownArrow.setAnimation(hideAnim);
            binding.chatDownArrow.setVisibility(View.GONE);
        }
    }

    private void getChatChannel() {
        FirestoreClient.getInstance().getUserInfoDocRef(mAuth.getUid())
                .collection(ENGAGED_CHAT_CHANNELS)
                .document(otherUserId)
                .get()
                .addOnSuccessListener(documentSnapshot -> {
                    if (documentSnapshot.exists()) {
                        chatChannelId = (String) documentSnapshot.get(CHANNEL_ID);
                        chatChannelFilesDir = FilesClient.getMessageFilesDirForChatChannel(this, chatChannelId);
                        messageAdapter.setChannelFilesDir(chatChannelFilesDir);
                        firstTimeChat = false;
                        firstTime = true;
                        loadMessages();
                        return;
                    }

                    binding.chatPb.setVisibility(View.INVISIBLE);
                    Log.i(TAG, "getChatChannel: newChatChannel = true");
                    newChatChannel = true;
                    firstTimeChat = true;
                    listenForNewChatChannels();
                })
                .addOnFailureListener(e -> {
                    Log.i(TAG, "getOrCreateChatChannel: " + e.getMessage());
                    Toast.makeText(this, "Failed to Load Chat", Toast.LENGTH_SHORT).show();
                });
    }

    private void createNewChatChannel(long sentTimeInMillis) {
        Log.i(TAG, "createNewChatChannel: current=" + currentUserName + " other=" + otherUserName);
        ArrayList<String> ids = new ArrayList<>(), names = new ArrayList<>();
        ids.add(mAuth.getUid());
        ids.add(otherUserId);
        names.add(currentUserName);
        names.add(otherUserName);
        chatChannelId = String.valueOf(System.currentTimeMillis());
        DocumentReference newChannel = chatChannelsCollection.document(chatChannelId);
        DocumentReference reference1 = userInfoDocRef.collection(ENGAGED_CHAT_CHANNELS).document(otherUserId);
        DocumentReference reference2 = FirestoreClient.getInstance().getUsersCollection().document(otherUserId).collection(ENGAGED_CHAT_CHANNELS).document(mAuth.getUid());
        HashMap<String, String> map1 = new HashMap<>(), map2 = new HashMap<>();
        map1.put(CHANNEL_ID, chatChannelId);
        map2.put(CHANNEL_ID, chatChannelId);
        WriteBatch writeNewChannel = FirebaseFirestore.getInstance().batch();
        writeNewChannel.set(newChannel, new ChatChannel(ids, names, null));
        writeNewChannel.set(reference1, map1);
        writeNewChannel.set(reference2, map2);
        writeNewChannel.commit()
                .addOnSuccessListener(aVoid -> {
                    chatChannelFilesDir = FilesClient.getMessageFilesDirForChatChannel(this, chatChannelId);
                    messageAdapter.setChannelFilesDir(chatChannelFilesDir);
                    Log.i(TAG, "createNewChatChannel: success");
                    newChatChannel = false;
                    firstTime = false;
                    listenForNewMessages();
                    checkForImageOrFile(sentTimeInMillis);
                })
                .addOnFailureListener(e -> {
                    Log.i(TAG, "createNewChatChannel: " + e.getMessage());
                    Toast.makeText(this, "Failed to Send Message", Toast.LENGTH_SHORT).show();
                });
    }

    // Realtime Updates
    private void listenForNewChatChannels() {
        ArrayList<String> ids = new ArrayList<>();
        ids.add(otherUserId);
        ids.add(mAuth.getUid());
        FirestoreClient.getInstance().getChatChannelCollection()
                .whereEqualTo(ChatChannel.USER_IDS, ids)
                .addSnapshotListener((queryDocumentSnapshots, e) -> {
                    if (e != null) {
                        Log.i(TAG, "listenForNewChatChannels: " + e.getMessage());
                        return;
                    }
                    if (!firstTime) {
                        assert queryDocumentSnapshots != null;
                        if (!queryDocumentSnapshots.getDocuments().isEmpty() && newChatChannel) {
                            newChatChannel = false;
                            chatChannelId = queryDocumentSnapshots.getDocuments().get(0).getId();
                            chatChannelFilesDir = FilesClient.getMessageFilesDirForChatChannel(this, chatChannelId);
                            messageAdapter.setChannelFilesDir(chatChannelFilesDir);
                            ChatChannel chatChannel = queryDocumentSnapshots.getDocuments().get(0).toObject(ChatChannel.class);
                            for (String s : chatChannel.getUserIds()) {
                                if (!s.equals(mAuth.getUid())) {
                                    otherUserId = s;
                                    break;
                                }
                            }
                            for (String s : chatChannel.getUserNames()) {
                                if (!s.equals(currentUserName)) {
                                    otherUserName = s;
                                    break;
                                }
                            }
                            Log.i(TAG, "listenForNewChatChannels: otherUserId=" + otherUserId);
                            Log.i(TAG, "listenForNewChatChannels: otherUserName=" + otherUserName);
                            listenForNewMessages();
                        }
                    } else firstTime = false;
                });
    }

    private void listenForNewMessages() {
        Query query;
        query = chatChannelsCollection.document(chatChannelId).collection(MESSAGES)
                .orderBy(Message.SENT_TIME_IN_MILLIS, Query.Direction.DESCENDING)
                .whereEqualTo(Message.SENDER_ID, otherUserId)
                .limit(1);
        query.addSnapshotListener((queryDocumentSnapshots, e) -> {
            if (e != null) {
                Log.i(TAG, "listenForNewMessages: " + e.getMessage());
                return;
            }
            if (queryDocumentSnapshots != null && !queryDocumentSnapshots.isEmpty()) {
                if (!firstTime) {
                    Message message = queryDocumentSnapshots.toObjects(Message.class).get(0);
                    if (messages.isEmpty() || messages.get(0).getSentTimeInMillis() != message.getSentTimeInMillis()) {
                        Log.i(TAG, "listenForNewMessages: newMessage=" + message.getText());
                        Log.i(TAG, "listenForNewMessages: newMessageTime=" + message.getSentTimeInMillis());
                        if (!messages.isEmpty())
                            Log.i(TAG, "listenForNewMessages: previousMessageTime=" + messages.get(0).getSentTimeInMillis());
                        else
                            Log.i(TAG, "listenForNewMessages: firstMessage");
                        messages.add(0, message);
                        binding.chatRecyclerView.setHasFixedSize(false);
                        messageAdapter.notifyItemInserted(0);
                        binding.chatRecyclerView.setHasFixedSize(true);
                        binding.chatRecyclerView.scrollToPosition(0);
                        checkForSmartReplies();
                    }
                } else firstTime = false;
            }
        });
    }

    // Showing Messages
    private void paginate() {
        if (!firstTimeChat) {
            Log.i(TAG, "paginate: ");
            loadMessages();
        }
    }

    private void loadMessages() {
        if (!endOfCollection) {
            Query query;
            if (lastMessage != null)
                query = chatChannelsCollection.document(chatChannelId).collection(MESSAGES)
                        .orderBy(Message.SENT_TIME_IN_MILLIS, Query.Direction.DESCENDING)
                        .startAfter(lastMessage)
                        .limit(MESSAGES_LIMIT);
            else
                query = chatChannelsCollection.document(chatChannelId).collection(MESSAGES)
                        .orderBy(Message.SENT_TIME_IN_MILLIS, Query.Direction.DESCENDING)
                        .limit(MESSAGES_LIMIT);
            query.get()
                    .addOnSuccessListener(queryDocumentSnapshots -> {
                        Log.i(TAG, "loadMessages: ");
                        if (lastMessage == null)
                            listenForNewMessages();
                        binding.chatPb.setVisibility(View.INVISIBLE);
                        if (!messages.isEmpty() && messages.get(messages.size() - 1).getSentTimeInMillis() == -1)
                            messages.remove(messages.size() - 1);
                        messages.addAll(queryDocumentSnapshots.toObjects(Message.class));
                        if (lastMessage == null)
                            if (queryDocumentSnapshots.getDocuments().get(0).toObject(Message.class).getSenderId().equals(otherUserId))
                                checkForSmartReplies();
                        if (queryDocumentSnapshots.size() == MESSAGES_LIMIT) {
                            messages.add(new Message(-1));
                            lastMessage = queryDocumentSnapshots.getDocuments().get(queryDocumentSnapshots.size() - 1);
                            messageAdapter.notifyItemRangeInserted(messages.size() - queryDocumentSnapshots.size(), queryDocumentSnapshots.size() + 1);
                        } else {
                            endOfCollection = true;
                            Log.i(TAG, "loadMessages: endOfCollection");
                            messageAdapter.notifyDataSetChanged();
                        }

                        loading = true;
                    })
                    .addOnFailureListener(e -> {
                        Log.i(TAG, "loadMessages: " + e.getMessage());
                        Toast.makeText(this, "Failed to Load Messages", Toast.LENGTH_SHORT).show();
                    });
        }
    }

    // Input Field
    private void showAttachmentOptions() {
        new MaterialAlertDialogBuilder(this)
                .setTitle("Choose an Attachment")
                .setItems(R.array.messageAttachmentOptions, (dialogInterface, i) -> {
                    switch (i) {
                        case 0:
                            checkForStoragePermission(IMAGE_REQUEST);
                            break;
                        case 1:
                            checkForStoragePermission(FILE_REQUEST);
                            break;
                    }
                })
                .show();
    }

    private void checkForImageOrFile(long messageTime) {
        if (imageUri != null) {
            newMessage.setType(Message.IMAGE);
            uploadImage(imageUri, messageTime);
            imageUri = null;
            return;
        }
        if (fileUri != null) {
            this.messageTime = messageTime;
            newMessage.setFileName(FilesClient.getFileName(fileUri, this));
            if (!receivingFileFromOtherApp)
                newMessage.setFileMIMEType(FilesClient.getFileType(fileUri, this));
            else
                newMessage.setFileMIMEType(intent.getType());
            newMessage.setType(Message.FILE);
            File newMessageFileDir = new File(chatChannelFilesDir, String.valueOf(messageTime));
            newMessageFileDir.mkdirs();
            newMessageFile = new File(newMessageFileDir, newMessage.getFileName());
            progressDialog.show();
            FilesClient.FileCopyTask fileCopyTask = new FilesClient.FileCopyTask(this, this, FilesClient.FROM_CHAT, newMessageFile);
            fileCopyTask.execute(fileUri);
            return;
        }
        newMessage.setType(Message.TEXT);
        uploadMessage(null);
    }

    // Uploading Data or Files
    private void uploadImage(Uri uri, long sentTimeInMillis) {
        CloudStorageClient.getInstance().getMessagesStorage()
                .child(String.valueOf(sentTimeInMillis))
                .putFile(uri)
                .addOnSuccessListener(taskSnapshot -> {
                    File receivingImage = new File(getFilesDir(), "receivingImage");
                    receivingImage.delete();
                    uploadMessage(null);
                })
                .addOnFailureListener(e -> {
                    File receivingImage = new File(getFilesDir(), "receivingImage");
                    receivingImage.delete();
                    imageUri = null;
                    Log.i(TAG, "storeMessageImage: " + e.getMessage());
                    failedToSend();
                });
    }

    private void uploadFile(Uri uri, long sentTimeInMillis, File newMessageFile, Message message) {
        message.setUploading(true);
        CloudStorageClient.getInstance().getMessagesStorage()
                .child(String.valueOf(sentTimeInMillis))
                .putFile(uri)
                .addOnProgressListener(taskSnapshot -> {
                    int progress = (int) (taskSnapshot.getBytesTransferred() * 100 / taskSnapshot.getTotalByteCount());
                    message.setFileProgress(progress);
                    int pos = messages.indexOf(message);
                    messages.set(pos, message);
                    messageAdapter.notifyItemChanged(pos);
                })
                .addOnSuccessListener(taskSnapshot -> {
                    if (receivingFileFromOtherApp) {
                        String fileName = intent.getStringExtra("fileName");
                        if (fileName != null) {
                            File receivingFileDir = new File(getFilesDir(), "receivingFileDir");
                            receivingFileDir.mkdirs();
                            File receivingFile = new File(receivingFileDir, fileName);
                            receivingFile.delete();
                        }
                    }
                    message.setUploading(false);
                    message.setFileProgress(-1);
                    messageAdapter.notifyItemChanged(messages.indexOf(message));
                    uploadMessage(newMessageFile);
                })
                .addOnFailureListener(e -> {
                    fileUri = null;
                    if (newMessageFile.exists())
                        newMessageFile.delete();
                    if (receivingFileFromOtherApp) {
                        String fileName = intent.getStringExtra("fileName");
                        if (fileName != null) {
                            File receivingFileDir = new File(getFilesDir(), "receivingFileDir");
                            receivingFileDir.mkdirs();
                            File receivingFile = new File(receivingFileDir, fileName);
                            receivingFile.delete();
                        }
                    }
                    Log.i(TAG, "storeMessageImage: " + e.getMessage());
                    failedToSend();
                });
    }

    public void onFileCopyTaskComplete() {
        progressDialog.dismiss();
        uploadFile(fileUri, messageTime, newMessageFile, newMessage);
        fileUri = null;
    }

    private void uploadMessage(File newMessageFile) {
        WriteBatch writeBatch = FirebaseFirestore.getInstance().batch();
        DocumentReference chatDocRef = chatChannelsCollection.document(chatChannelId);
        writeBatch.update(chatDocRef, ChatChannel.LAST_MESSAGE, newMessage);
        writeBatch.set(chatDocRef.collection(MESSAGES).document(String.valueOf(newMessage.getSentTimeInMillis())), newMessage);
        writeBatch.commit()
                .addOnSuccessListener(aVoid -> sent())
                .addOnFailureListener(e -> {
                    if (newMessageFile != null && newMessageFile.exists())
                        newMessageFile.delete();
                    Log.i(TAG, "uploadMessage: " + e.getMessage());
                    failedToSend();
                });
    }

    // Handing the Uploads
    private void sending() {
        binding.chatRecyclerView.setHasFixedSize(false);
        messageAdapter.setNewPhotoUri(imageUri);
        if (!messages.isEmpty())
            messages.add(0, newMessage);
        else
            messages.add(newMessage);
        messageAdapter.setNewMessage(true);
        messageAdapter.notifyItemInserted(0);
        binding.chatRecyclerView.scrollToPosition(0);
        binding.chatRecyclerView.setHasFixedSize(true);
        // ML Kit suggests replies to the last message in a conversation history. The last message should be from a non-local user.
        hideSmartReplies();
    }

    private void sent() {
        Log.i(TAG, "sent: ");
//        imageUri = null;
//        fileUri = null;
        messageAdapter.setNewPhotoUri(null);
        messageAdapter.setNewMessage(false);
        messageAdapter.notifyItemChanged(0);
    }

    private void failedToSend() {
        Toast.makeText(this, "Failed to Send Message. Try Again Later", Toast.LENGTH_SHORT).show();
    }

    // Handling Click Events on Messages
    private void showImage(int pos, ImageView imageView) {
//        Todo: Handle when message is still in sending stage
        Intent intent = new Intent(ChatActivity.this, ImageActivity.class);
        ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(ChatActivity.this, imageView, "image");
        intent.putExtra("timeInMillis", messages.get(pos).getSentTimeInMillis());
        startActivity(intent, options.toBundle());
    }

    private void handleFileClick(int pos, Message message) {
        // Todo: Handle if user leaves ChatActivity after clicking download
        File messageFile = FilesClient.getMessageFile(chatChannelFilesDir, message);
        if (messageFile.exists()) {
            Uri uri = FilesClient.getUriForFile(messageFile, this);
            grantUriPermission(getPackageName(), uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
            Intent intent = new Intent(Intent.ACTION_VIEW)
                    .setDataAndType(uri, message.getFileMIMEType())
                    .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
            startActivity(Intent.createChooser(intent, "Open File with..."));
        } else {
            // Todo: Handle if Message Failed to Upload
            message.setFileProgress(0);
            messages.set(pos, message);
            messageAdapter.notifyItemChanged(pos);
            CloudStorageClient.getInstance().getMessageFileRef(message.getSentTimeInMillis())
                    .getFile(messageFile)
                    .addOnProgressListener(taskSnapshot -> {
                        int progress = (int) (taskSnapshot.getBytesTransferred() * 100 / taskSnapshot.getTotalByteCount());
                        message.setFileProgress(progress);
                        messages.set(pos, message);
                        messageAdapter.notifyItemChanged(pos);
                    })
                    .addOnSuccessListener(taskSnapshot -> {
                        message.setFileProgress(-1);
                        messages.set(pos, message);
                        messageAdapter.notifyItemChanged(pos);
                    })
                    .addOnFailureListener(e -> {
                        messageFile.delete();
                        Log.i(TAG, "checkIfFileExists: " + e.getMessage());
                        failedToSend();
                    });
        }
    }

    private void handleFileLongClick(int pos, Message message) {
        new MaterialAlertDialogBuilder(this)
                .setTitle("File Options")
                .setItems(R.array.messageFileOptions, (dialogInterface, i) -> {
                    switch (i) {
                        case 0:
                            FilesClient.deleteMessageFile(chatChannelFilesDir, message);
                            messageAdapter.notifyItemChanged(pos);
                            break;
                        case 1:
                            shareClient.shareMessageFile(message.getFileMIMEType(), FilesClient.getMessageFile(chatChannelFilesDir, message));
                    }
                })
                .show();
    }

    // Smart Replies
    private void checkForSmartReplies() {
        Log.i(TAG, "checkForSmartReplies: ");
        textMessages.clear();
        // ML Kit uses up to 10 of the most recent messages from a conversation history to generate reply suggestions
        if (messages.size() >= 10) {
            for (Message message : messages.subList(0, 9))
                textMessages.add(message.getTextMessageForUser(mAuth.getUid()));
        } else {
            for (Message message : messages)
                textMessages.add(message.getTextMessageForUser(mAuth.getUid()));
        }
        Collections.reverse(textMessages);
        smartReplyGenerator.suggestReplies(textMessages)
                .addOnSuccessListener(suggestionResult -> {
                    if (suggestionResult.getStatus() == SmartReplySuggestionResult.STATUS_NOT_SUPPORTED_LANGUAGE) {
                        Log.i(TAG, "generateSmartReplies: STATUS_NOT_SUPPORTED_LANGUAGE");
                        hideSmartReplies();
                    } else if (suggestionResult.getStatus() == SmartReplySuggestionResult.STATUS_SUCCESS)
                        showSmartReplies(suggestionResult.getSuggestions());
                })
                .addOnFailureListener(e -> {
                    Log.i(TAG, "generateSmartReplies: " + e.getMessage());
                    hideSmartReplies();
                });
    }

    private void showSmartReplies(List<SmartReplySuggestion> replySuggestions) {
        Log.i(TAG, "showSmartReplies: ");
        replies.clear();
        for (SmartReplySuggestion smartReplySuggestion : replySuggestions) {
            if (!smartReplySuggestion.getText().isEmpty())
                replies.add(smartReplySuggestion.getText());
        }
        if (replies.size() == 2)
            smartReplyChips[2].setVisibility(View.GONE);
        else if (replies.size() == 1) {
            smartReplyChips[1].setVisibility(View.GONE);
            smartReplyChips[2].setVisibility(View.GONE);
        }
        for (String s : replies)
            smartReplyChips[replies.indexOf(s)].setText(s);
        binding.smartRepliesContainer.setVisibility(View.VISIBLE);
    }

    private void hideSmartReplies() {
        binding.smartRepliesContainer.setVisibility(View.GONE);
    }

    private void sendSmartReply(View view) {
        if (imageUri == null && fileUri == null) {
            binding.chatMessageEt.setText(null);
            binding.chatImgCard.setVisibility(View.GONE);
            newMessage = new Message(replies.get(Integer.parseInt(view.getTag().toString())), mAuth.getUid(), otherUserId, currentUserName, Message.TEXT, System.currentTimeMillis());
            sending();
            checkForImageOrFile(newMessage.getSentTimeInMillis());
        } else {
            newMessage = new Message(replies.get(Integer.parseInt(view.getTag().toString())), mAuth.getUid(), otherUserId, currentUserName, Message.TEXT, System.currentTimeMillis());
            binding.chatMessageEt.setText(newMessage.getText());
            hideSmartReplies();
        }
    }

    // Receiving Data From other Apps
    private void handleTextSharing() {
        messageText = intent.getStringExtra(android.content.Intent.EXTRA_TEXT);
        binding.chatMessageEt.setText(messageText);
        binding.chatMessageEt.requestFocus();
    }

    private void handleImageSharing() {
        receivingFileFromOtherApp = true;
        messageText = intent.getStringExtra(android.content.Intent.EXTRA_TEXT);
        File receivingImage = new File(getFilesDir(), "receivingImage");
        imageUri = Uri.fromFile(receivingImage);
        binding.chatImg.setImageURI(imageUri);
        new Handler().postDelayed(() -> binding.chatImgCard.setVisibility(View.VISIBLE), 100);
        binding.chatMessageEt.setText(messageText);
    }

    private void handleFileSharing() {
        receivingFileFromOtherApp = true;
        messageText = intent.getStringExtra(android.content.Intent.EXTRA_TEXT);
        String fileName = intent.getStringExtra("fileName");
        File receivingFileDir = new File(getFilesDir(), "receivingFileDir");
        receivingFileDir.mkdirs();
        File receivingFile = new File(receivingFileDir, fileName);
        fileUri = Uri.fromFile(receivingFile);
        binding.chatFileName.setText(FilesClient.getFileName(fileUri, this));
        binding.chatFileCard.setVisibility(View.VISIBLE);
    }

    // Opening Images and Files
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == IMAGE_REQUEST) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED)
                openPhoneGallery();
        }
        if (requestCode == FILE_REQUEST) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED)
                openFiles();
        }
    }

    public void openPhoneGallery() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, IMAGE_REQUEST);
    }

    public void openFiles() {
        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.setType("*/*");
        startActivityForResult(intent, FILE_REQUEST);
    }

    private void checkForStoragePermission(int requestCode) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if (this.checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)
                showPermissionRequestDialog(requestCode);
            else {
                switch (requestCode) {
                    case IMAGE_REQUEST:
                        openPhoneGallery();
                        break;
                    case FILE_REQUEST:
                        openFiles();
                }
            }
        } else
            switch (requestCode) {
                case IMAGE_REQUEST:
                    openPhoneGallery();
                    break;
                case FILE_REQUEST:
                    openFiles();
            }
    }

    @RequiresApi(api = Build.VERSION_CODES.M)
    private void showPermissionRequestDialog(int requestCode) {
        new MaterialAlertDialogBuilder(this)
                .setTitle("Storage Permission")
                .setMessage(getResources().getString(R.string.readExternalStorageRequest))
                .setNegativeButton("Not now", (dialog, which) -> {
                })
                .setPositiveButton("Continue", (dialog, which) -> {
                    requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, requestCode);
                })
                .show();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        fileUri = null;
        imageUri = null;
        if (requestCode == IMAGE_REQUEST && data != null) {
            if (binding.chatFileCard.getVisibility() == View.VISIBLE)
                binding.chatFileCard.setVisibility(View.GONE);
            imageUri = data.getData();
            binding.chatImg.setImageURI(imageUri);
            new Handler().postDelayed(() -> binding.chatImgCard.setVisibility(View.VISIBLE), 100);
        }
        if (requestCode == FILE_REQUEST && data != null && resultCode == RESULT_OK) {
            if (binding.chatImgCard.getVisibility() == View.VISIBLE)
                binding.chatImgCard.setVisibility(View.GONE);
            fileUri = data.getData();
            binding.chatFileName.setText(FilesClient.getFileName(fileUri, this));
            new Handler().postDelayed(() -> binding.chatFileCard.setVisibility(View.VISIBLE), 100);
            Log.i(TAG, "onActivityResult: fileType = " + FilesClient.getFileType(fileUri, this));
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                onBackPressed();
                return true;
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    public void onBackPressed() {
        if (binding.chatImgCard.getVisibility() == View.VISIBLE) {
            imageUri = null;
            binding.chatImgCard.setVisibility(View.GONE);
            return;
        }
        if (binding.chatFileCard.getVisibility() == View.VISIBLE) {
            fileUri = null;
            binding.chatFileCard.setVisibility(View.GONE);
            return;
        }
        if (receivingFileFromOtherApp) {
            String fileName = intent.getStringExtra("fileName");
            File receivingFileDir = new File(getFilesDir(), "receivingFileDir");
            receivingFileDir.mkdirs();
            if (fileName != null) {
                File receivingFile = new File(receivingFileDir, fileName);
                receivingFile.delete();
            }
            File receivingImage = new File(getFilesDir(), "receivingImage");
            receivingImage.delete();
        }
        if (!isTaskRoot() || receivingData)
            super.onBackPressed();
        else {
            Intent intent = new Intent(ChatActivity.this, HomeActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            startActivity(intent);
            finish();
        }
    }
}